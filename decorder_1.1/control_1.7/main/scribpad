#include "pcnt.h"
#include "cpg.h"
#include "UART.h"
#include "ble.h"

static DRAM_ATTR float CPG_frequency = 0.10f;

//============================================================PID==================================================================
#define TAG_PID "PID"
#define PID_QUEUE_LENGTH 1

// ====================== Globals ======================
static DRAM_ATTR Motor motors[NUM_MOTORS];
QueueHandle_t motor_command_queue;
TaskHandle_t pid_loop_task = NULL;

// ====================== SAFE DOUBLE BUFFER ======================
volatile DRAM_ATTR float motor_cmd_buffer[2][NUM_MOTORS];
volatile DRAM_ATTR uint8_t current_write_index = 0;  // PID reads from this
portMUX_TYPE pid_buffer_swap_mux = portMUX_INITIALIZER_UNLOCKED;

static uint8_t prev_read_index=0;
static uint8_t stall_count[NUM_MOTORS] = {0};
static uint64_t start;

void update_i2c_motor_commands(float *new_commands) {
    uint8_t write_buffer = 1 - current_write_index;  // Write to opposite buffer
    
    // Copy to back buffer
    memcpy((void*)motor_cmd_buffer[write_buffer], new_commands, sizeof(float) * NUM_MOTORS);

    // Atomic swap - ensures PID sees consistent snapshot
    taskENTER_CRITICAL(&pid_buffer_swap_mux);
    current_write_index = write_buffer;
    taskEXIT_CRITICAL(&pid_buffer_swap_mux);
}

// ====================== PID Functions ======================
void PIDController_Init(PIDController *pid) {
    pid->integrator = 0.0f;
    pid->prevError = 0.0f;
    pid->differentiator = 0.0f;
    pid->prevMeasurement = 0.0f;
    pid->output = 0.0f;
}

void update_PID_gain(void) {
    if (xSemaphoreTake(uart_mutex, 0) == pdTRUE) {
        float freq_scale = fminf(CPG_frequency / 0.1f, 3.0f);  // 1x at 0.1Hz, up to 3x at higher
        for (int i = 0; i < NUM_MOTORS; i++) {
            // Base from update_motors, scaled
            motors[i].pos_pid.Kp = update_motors[i].pos_pid.Kp * (2.0f + 0.5f * freq_scale);  // +50-150% for speed
            motors[i].pos_pid.Kd = update_motors[i].pos_pid.Kd * (1.0f + 0.8f * freq_scale);  // More damping for high freq
            motors[i].pos_pid.Ki = update_motors[i].pos_pid.Ki * 0.7f;  // Reduce integral to fight drift
            // Cap limits to prevent saturation
            motors[i].pos_pid.limMaxInt = 200.0f / freq_scale;  // Tighter at high freq
        }
        xSemaphoreGive(uart_mutex);
    }
}

void PIDController_Update(PIDController *pid, float setpoint, int measurement, uint8_t i) {
    
    pid->prevError = pid->error;
    pid->lastOutput = pid->output;
    pid->prevMeasurement = (float)measurement;
  
    pid->error = setpoint - (float)measurement;

    //ESP_LOGE(TAG, "CPG[%1d] (out: %.2f)",i ,pid->error);

    // Proportional term
    pid->proportional = pid->Kp * pid->error;
    //derivative term
    pid->differentiator = pid->Kd*(pid->error - pid->prevError)/pid->T;
    //integral term
    pid->integrator += pid->Ki *pid->error*pid->T;

    // Clamp integrator
    if (pid->integrator > pid->limMaxInt){
        pid->integrator = pid->limMaxInt;
    }
    if (pid->integrator < pid->limMinInt){
        pid->integrator = pid->limMinInt;
    }

    if(fabs(pid->error)<=STOP_THRESHOLD*10){
      pid->integrator *= 0.9f; // decay
    }

    //calculate PID output 
    pid->output = pid->proportional +pid->differentiator+pid->integrator;

    // After output calc, before clamp:
   float raw_output = pid->proportional + pid->differentiator + pid->integrator;

   // Anti-windup: Back-calculate integrator if saturated
   if (raw_output > pid->limMax) {
     pid->integrator -= (raw_output - pid->limMax) * pid->Ki * pid->T;  // Undo excess
     pid->output = pid->limMax;
    } else if (raw_output < pid->limMin) {
     pid->integrator -= (raw_output - pid->limMin) * pid->Ki * pid->T;
     pid->output = pid->limMin;
    } else {
     pid->output = raw_output;
    }

    pid->output = 0.5f * pid->output + 0.5f * pid->lastOutput;

    //ESP_LOGE(TAG, "CPG[%1d] (out: %.2f)",i ,pid->output)


}

// ====================== Position Loop ======================
void run_position_loop(){

    static int current_encoders[NUM_MOTORS] = {0};  // This packet will hold our local, consistent copy of all encoder value
    static float pidOutput[NUM_MOTORS];
    static uint32_t log_counter = 0;

    update_PID_gain();


    /*if( motors[0].active == true){
        // Throttled log (every ~100 loops ~1s)
        log_counter++;
        if (log_counter % 100 == 0) {
            ESP_LOGE("CPG IN","CPG Target[0]: %.2f\n", motors[0].target_position);
        }
    }*/
        

    // At the start of the loop, get the MOST RECENT encoder snapshot
    for (int i = 0; i < NUM_ENCODERS; i++){
      ESP_ERROR_CHECK(pcnt_unit_get_count(pcnt_unit[i],&current_encoders[i]));
      //ESP_LOGE(TAG, "PCNT[%1d] (count: %1d)",i ,current_encoders[i]);
    }
        
        for (int i = 0; i < NUM_MOTORS; i++) {

            motors[i].current_position = current_encoders[i];

            //ESP_LOGE(TAG, "CPG[%1d] (count: %.2f)",i ,motors[i].target_position);

            PIDController_Update(&motors[i].pos_pid,motors[i].target_position,
                                 motors[i].current_position, i);

            if (!motors[i].active) {
               if(motors[i].current_position<=STOP_THRESHOLD*5){
                  motors[i].pos_pid.output = 0;
                  continue;
                }
            }

            float abs_error = fabs(motors[i].pos_pid.error);
            if (abs_error > TOL) {
                if (motors[i].current_position == motors[i].last_enc_val) {
                    stall_count[i]++;
                    if (stall_count[i] >= 5) {
                        //motors[i].pos_pid.output = PWM_MAX;
                    }
                } else {
                    stall_count[i] = 0;
                }
            }

          /*float joint_vel = fabs(motors[i].current_position - (float)motors[i].last_enc_val) / PID_DT;
          if (i==4 && log_counter % 2000 == 0)ESP_LOGI("CPG", "Joint[0] vel=%.0f counts/sec at f=%.1f Hz", joint_vel, CPG_frequency);*/
          motors[i].last_enc_val = motors[i].current_position;

        }

        for(int i =0;i<NUM_MOTORS;i++){
          pidOutput[i] = motors[i].pos_pid.output;
        }

        // send pid output to the i2c
        update_i2c_motor_commands(pidOutput);

        xTaskNotifyGive(uart_send_task);

        /*if (log_counter % 100 == 0) {
          for (int sample_i = 0; sample_i < NUM_MOTORS; sample_i += 2) {  // Sample hips/knees
             int osc_idx = sample_i;  // Assume direct map
             float cpg_amp = cpg_network[osc_idx].amplitude;
             ESP_LOGI("PID_CPG", "Motor[%d] error=%.1f, output=%.1f, target=%.1f | CPG amp=%.0f, phase=%.2f",
                       sample_i, motors[sample_i].pos_pid.error, motors[sample_i].pos_pid.output, motors[sample_i].target_position,
                       cpg_amp, cpg_network[osc_idx].phase);
            }
        }*/

        //static uint32_t pid_log_counter = 0;
        //pid_log_counter++;
       /* if (pid_log_counter % 100 == 0) {  // ~50ms
             ESP_LOGI("PID", "Motor[0] error=%.0f, output=%.1f; Motor[4] error=%.0f, output=%.1f",
             motors[0].pos_pid.error, motors[0].pos_pid.output,
             motors[4].pos_pid.error, motors[4].pos_pid.output);
        }*/
        
        xQueueOverwrite(encorderQue,current_encoders);

        // PID work
        uint64_t elapsed = esp_timer_get_time() - start;
       // if (elapsed > CPG_UPDATE_RATE_US) ESP_LOGW(TAG_PID, "CPG and PID loop took %llu µs", elapsed);

}

// ====================== Motor Setup ======================
void pid_app_main(void) {
    ESP_LOGI(TAG_PID, "Starting PID application...");
    
    for (int i = 0; i < NUM_MOTORS; i++) {
        motors[i].m_num = i + 1;
        motors[i].target_position = 0.0f;
        motors[i].current_position = 0;
        motors[i].active = false;

        motors[i].pos_pid.Kp = 2.00f;
        motors[i].pos_pid.Ki = 0.00f;
        motors[i].pos_pid.Kd = 0.00f;

        motors[i].pos_pid.T = PID_DT;
        motors[i].pos_pid.limMin = -PWM_MAX;
        motors[i].pos_pid.limMax = PWM_MAX;
        motors[i].pos_pid.limMinInt = -300.0f;
        motors[i].pos_pid.limMaxInt = 300.0f;

        PIDController_Init(&motors[i].pos_pid);
    }

    //xTaskCreatePinnedToCore(position_loop_task, "pos_loop", 5120, NULL, 20, &pid_loop_task,1);

    ESP_LOGI(TAG_PID, "PID application started successfully");
}  


//===========================================================CPG=================================================================

#define TAG "CPG"

const float TWO_PI = 2.0f * 3.1415926535f; // Use a float constant

// Define the global CPG variables
Oscillator cpg_network[NUM_OSCILLATORS];
osc_pram CPG_network_pram;
volatile SequenceMode current_mode;
float coupling_weights[NUM_OSCILLATORS][NUM_OSCILLATORS];
float phase_offsets[NUM_OSCILLATORS][NUM_OSCILLATORS];
static SemaphoreHandle_t cpg_params_mutex;

// Timer handle for high-frequency CPG updates
static esp_timer_handle_t cpg_timer_handle;
static TaskHandle_t cpg_task_handle = NULL;

void motor_set(uint8_t i, float target, bool set) {
    // FIXED: Sign flip for right legs (FR/BR: indices 1,3,5,7) for symmetry (forward gait)
    bool is_right_leg = (i == BLK || i == BRK);  // Adjust indices if mapping differs
    float signed_target = is_right_leg ? -target : target;  // Mirror right for opposite swing

    // Velocity FF (on signed target for correct direction)
    float phase = cpg_network[i].phase;
    float vel_ff = cpg_network[i].amplitude * cpg_network[i].omega * cosf(phase);
    motors[i].target_position = signed_target + (vel_ff * PID_DT * 0.2f);  // Keep your tuned gain
    motors[i].active = set;
}

// Timer callback function (runs in ISR context)
void IRAM_ATTR cpg_timer_callback(void* arg) {
    static uint32_t sequence_counter = 0;  // Static persists between calls
    
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;

     // Send notification to CPG task
     vTaskNotifyGiveFromISR(cpg_task_handle, &xHigherPriorityTaskWoken);
    
    if (xHigherPriorityTaskWoken) {
        portYIELD_FROM_ISR();
    }
}

void cpg_update_task(void *arg) {
    uint32_t last_sequence = 0;
    float d_phi[NUM_OSCILLATORS]; // To store the change in phase for each oscillator

    while (1) {
      
      ulTaskNotifyTake(pdTRUE, portMAX_DELAY);

      start = esp_timer_get_time();

      if (xSemaphoreTake(cpg_params_mutex, pdMS_TO_TICKS(10)) == pdTRUE) {

        float phase[NUM_OSCILLATORS];

        for(int i =0;i<NUM_OSCILLATORS; i++){
           phase[i] = cpg_network[i].phase;  
        }

        // NEW: Compute/assign global_max_amp here (uses pram, but could call compute_max_amp() if dynamic)
        float global_max_amp = CPG_network_pram.max_amp;  // Or: compute_max_amp();

        // --- 1. Calculate phase changes for all oscillators ---
        for (int i = 0; i < NUM_OSCILLATORS; i++) { 

            float coupling_term = 0.0f;

            // --- Amplitude stabilization ---
            float target_amp = (i % 2 == 0) ? CPG_network_pram.hip_amp:CPG_network_pram.knee_amp;
            cpg_network[i].amplitude += 0.005f * (target_amp - cpg_network[i].amplitude)*CPG_DT; // smooth correction

            
            // --- Bias correction (prevent drift) ---
            float target_offset = (i % 2 != 0) ? CPG_network_pram.knee_offset:CPG_network_pram.hip_offset;
            cpg_network[i].offset += 0.01f * (target_offset - cpg_network[i].offset)*CPG_DT;
            
           
            // Sum the influence of all *other* oscillators (j) on this one (i)
            for (int j = 0; j < NUM_OSCILLATORS; j++) {
                if (i == j) continue; // An oscillator doesn't couple to itself

                float sin_term = sinf(phase[j] - phase[i] - phase_offsets[i][j]);
                // FIXED: Normalized coupling (prevents low-amp jitter)
                //float rel_amp = fminf(cpg_network[i].amplitude, cpg_network[j].amplitude); //Use min(amp_i, amp_j) or (amp_i * amp_j) / (amp_i + amp_j) for symmetric pull.
                float norm_amp = cpg_network[i].amplitude / global_max_amp;  // Normalize: 1.0 for strongest, <1 for weak
                
                coupling_term += coupling_weights[i][j] * norm_amp * sin_term;  // Relative, not absolute amp
            }
            
            // The final "change in phase" formula
            //d_phi[i] = cpg_network[i].omega + coupling_term; 
            float damping = 0.1f;
            d_phi[i] = (1.0f - damping) * cpg_network[i].omega + damping * coupling_term;
        }

        // --- 2. Update all phases and calculate outputs ---
        // (We do this in a separate loop to prevent using "new" values
        // in the calculation for the same time step)
        for (int i = 0; i < NUM_OSCILLATORS; i++) {
            
            // Apply the change: new_phase = old_phase + (change * time_step)
            cpg_network[i].phase += d_phi[i] * CPG_DT;

            // Wrap the phase (keep it between 0 and 2*PI)
            cpg_network[i].phase = fmodf(cpg_network[i].phase, TWO_PI);
            if (cpg_network[i].phase < 0.0f) cpg_network[i].phase += TWO_PI;

            // --- 3. Calculate the final motor setpoint ---
            cpg_network[i].output = cpg_network[i].offset + 
                                    cpg_network[i].amplitude * sinf(cpg_network[i].phase);

            if (cpg_network[i].amplitude != 0) {
                motor_set(i, cpg_network[i].output, true);
            } else {
                motor_set(i, cpg_network[i].offset, false);
            }
        
        } 
        // --- Give the Mutex Back ---
            xSemaphoreGive(cpg_params_mutex);
        // Only run the pid loop if we successfully updated cpg.
          run_position_loop();
          
        }else {
            ESP_LOGE(TAG, "CPG task failed to get mutex!");
        }

    }
}

// A helper function to set parameters for an oscillator
void set_oscillator_params(int i, float omega, float amp, float offset) {
    cpg_network[i].omega = omega;
    cpg_network[i].amplitude = amp;
    cpg_network[i].offset = offset;
}

// Call this from sequence_runner_task to set the IDLE gait
void set_gait_idle() {
    // Stop all oscillators by setting their amplitude to 0
    for(int i=0; i < NUM_OSCILLATORS; i++) {
        // Use a default offset (e.g., 0) or a "stand" position
        float stand_offset = 0;
        if (i % 2 != 0) stand_offset = 0;// Example: knees bent

        cpg_network[i].phase = 0;        
        cpg_network[i].output = stand_offset; 

        set_oscillator_params(i, 0, 0, stand_offset); // Freq=0, Amp=0
        
    }
    // No coupling needed
    memset(coupling_weights, 0, sizeof(coupling_weights));
    memset(phase_offsets, 0, sizeof(phase_offsets));
}

// Call this to set the TROT gait
void set_gait_trot() {
    // --- 1. Reset all couplings ---
    memset(coupling_weights, 0, sizeof(coupling_weights));
    memset(phase_offsets, 0, sizeof(phase_offsets));

    // --- 2. Set Oscillator base parameters ---
    CPG_network_pram.base_freq = TWO_PI *CPG_frequency; //0.2 1.0 Hz (1 cycle/sec)
    CPG_network_pram.hip_amp = 16352.0f; // Example: 1500 counts swing
    CPG_network_pram.knee_amp = 32704.0f;   // Example: 800 counts lift
    CPG_network_pram.hip_offset = 0.0f;   //Hip center position
    CPG_network_pram.knee_offset = 0.0f; // Example: knee center position

    // set max_amp safely
     CPG_network_pram.max_amp = fmaxf(CPG_network_pram.hip_amp, CPG_network_pram.knee_amp);
     if (CPG_network_pram.max_amp < 1e-3f) CPG_network_pram.max_amp = 1.0f; // fallback

    // Set params for all Hips
    set_oscillator_params(FLH, CPG_network_pram.base_freq, CPG_network_pram.hip_amp, CPG_network_pram.hip_offset);
    set_oscillator_params(FRH, CPG_network_pram.base_freq, CPG_network_pram.hip_amp, CPG_network_pram.hip_offset);
    set_oscillator_params(BLH, CPG_network_pram.base_freq, CPG_network_pram.hip_amp, CPG_network_pram.hip_offset);
    set_oscillator_params(BRH, CPG_network_pram.base_freq, CPG_network_pram.hip_amp, CPG_network_pram.hip_offset);
    
    // Set params for all Knees
    set_oscillator_params(FLK, CPG_network_pram.base_freq, CPG_network_pram.knee_amp, CPG_network_pram.knee_offset);
    set_oscillator_params(FRK, CPG_network_pram.base_freq, CPG_network_pram.knee_amp, CPG_network_pram.knee_offset);
    set_oscillator_params(BLK, CPG_network_pram.base_freq, CPG_network_pram.knee_amp, CPG_network_pram.knee_offset);
    set_oscillator_params(BRK, CPG_network_pram.base_freq, CPG_network_pram.knee_amp, CPG_network_pram.knee_offset);

    // --- 3. Define Coupling ---
    float K_intra_leg = 10.0f; // Strong coupling between a hip and its knee
    float K_inter_leg = 5.0f;  // Medium coupling between legs

    // === INTRA-LEG Coupling (Hip to Knee) ===
    // We want the knee to lift (e.g., sin(phi)=1) *before* the hip
    // moves forward (e.g., sin(phi)=0 -> 1).
    // A -90 degree (-PI/2) offset on the knee relative to the hip is common.
    //if(KH_offset==0){
     float  KH_offset =4.0f;
    //}

    float knee_lag = -TWO_PI / KH_offset;// Knee lags hip by 90 deg
    // FL leg
    coupling_weights[FLK][FLH] = K_intra_leg; // Knee listens to Hip
    phase_offsets[FLK][FLH] = knee_lag;
    // FR leg
    coupling_weights[FRK][FRH] = K_intra_leg;
    phase_offsets[FRK][FRH] = knee_lag;
    // BL leg
    coupling_weights[BLK][BLH] = K_intra_leg;
    phase_offsets[BLK][BLH] = knee_lag;
    // BR leg
    coupling_weights[BRK][BRH] = K_intra_leg;
    phase_offsets[BRK][BRH] = knee_lag;
    
    // === INTER-LEG Coupling (Hip to Hip) ===
    // Trot: Diagonals are in-phase (0 offset)
    //       Opposing diagonals are out-of-phase (PI offset)

    // FLH (0) <-> BRH (6) :: In-phase (0)
    coupling_weights[FLH][BRH] = K_inter_leg;
    phase_offsets[FLH][BRH] = 0;
    coupling_weights[BRH][FLH] = K_inter_leg;
    phase_offsets[BRH][FLH] = 0;
    
    // FRH (2) <-> BLH (4) :: In-phase (0)
    coupling_weights[FRH][BLH] = K_inter_leg;
    phase_offsets[FRH][BLH] = 0;
    coupling_weights[BLH][FRH] = K_inter_leg;
    phase_offsets[BLH][FRH] = 0;
    
    // FLH (0) <-> FRH (2) :: Out-of-phase (PI)
    coupling_weights[FLH][FRH] = K_inter_leg;
    phase_offsets[FLH][FRH] = M_PI;
    coupling_weights[FRH][FLH] = K_inter_leg;
    phase_offsets[FRH][FLH] = M_PI;
    
    // ... (and so on for all other hip-to-hip pairs) ...
    // FLH(0) <-> BLH(4) :: Out-of-phase (PI)
    coupling_weights[FLH][BLH] = K_inter_leg;
    phase_offsets[FLH][BLH] = M_PI;
    coupling_weights[BLH][FLH] = K_inter_leg;
    phase_offsets[BLH][FLH] = M_PI;

    // FRH(2) <-> BRH(6) :: Out-of-phase (PI)
    coupling_weights[FRH][BRH] = K_inter_leg;
    phase_offsets[FRH][BRH] = M_PI;
    coupling_weights[BRH][FRH] = K_inter_leg;
    phase_offsets[BRH][FRH] = M_PI;

    // BLH(4) <-> BRH(6) :: Out-of-phase (PI)
    coupling_weights[BLH][BRH] = K_inter_leg;
    phase_offsets[BLH][BRH] = M_PI;
    coupling_weights[BRH][BLH] = K_inter_leg;
    phase_offsets[BRH][BLH] = M_PI;

    // Seed trot pattern with initial phases for instant equilibrium
// Group 1 (FL/BR): hips at 0
cpg_network[FLH].phase = 0.0f;
cpg_network[BRH].phase = 0.0f;
cpg_network[FLK].phase = 0.0f + (M_PI / 2.0f);  // Knee leads hip by 90° (from knee_lag = -PI/2)
cpg_network[BRK].phase = 0.0f + (M_PI / 2.0f);

// Group 2 (FR/BL): hips at PI (anti-phase to Group 1)
cpg_network[FRH].phase = M_PI;
cpg_network[BLH].phase = M_PI;
cpg_network[FRK].phase = M_PI + (M_PI / 2.0f);  // Wrap if needed: fmod(1.5*PI, 2*PI)
cpg_network[BLK].phase = M_PI + (M_PI / 2.0f);

}

uint8_t get_mode(void){
  taskENTER_CRITICAL(&ble_mux);
  current_mode =(SequenceMode)byte_val[0];
  taskEXIT_CRITICAL(&ble_mux);
  return (uint8_t)current_mode;
}


void sequence_runner_task(void *arg) {
    uint8_t mode;
    uint8_t last_mode = 255; // Force an update on first run

    while (1) {
        // get_set_point(); // You might not need this anymore,
                         // Amplitudes/Offsets are set by the gait function.
                         // You could use BLE to tune them, though!

        mode = 1;//get_mode();

        if (mode != last_mode) { // Only update when the mode *changes*
            ESP_LOGI(TAG, "Mode change detected: %d", mode);
            
            // --- Take the Mutex ---
          if (xSemaphoreTake(cpg_params_mutex, 100) == pdTRUE) {

            switch (mode) {
                case MODE_CRAWL:
                    // You'll need to write set_gait_crawl()
                    // set_gait_crawl();
                    set_gait_trot(); 
                    ESP_LOGI(TAG, "Setting CRAWL gait");
                    break;

                case MODE_TURTLE: // Let's map this to TROT
                    set_gait_trot();
                    ESP_LOGI(TAG, "Setting TROT gait");
                    break;

                case MODE_STANDBY:
                    break;
                case MODE_IDLE:
                    set_gait_idle();
                    ESP_LOGI(TAG, "Setting IDLE gait");
                    break;

                default:
                    // Maybe just default to IDLE
                    set_gait_idle();
                    break;
            }
            last_mode = mode; // Remember the last mode
        
         // --- Give the Mutex Back ---
         xSemaphoreGive(cpg_params_mutex);

         } else {
                ESP_LOGE(TAG, "Seq. task failed to get mutex!");
            }
        }

        vTaskDelay(pdMS_TO_TICKS(100)); // Check for a new mode 10 times/sec
    }
}

void hardware_Timer_setup(void){
    // Setup high-resolution timer for 10 kHz
    esp_timer_create_args_t timer_args = {
        .callback = &cpg_timer_callback,  // Function to call
        .arg = NULL,                      // Argument passed to callback
        .dispatch_method = ESP_TIMER_TASK, // How to dispatch callback
        .name = "cpg_timer"               // Timer name for debugging
    };

    if (esp_timer_create(&timer_args, &cpg_timer_handle) != ESP_OK) {
        ESP_LOGE(TAG, "Failed to create CPG timer!");
        return;
    }

    // Start the 10 kHz timer
    if (esp_timer_start_periodic(cpg_timer_handle, CPG_UPDATE_RATE_US) != ESP_OK) {
        ESP_LOGE(TAG, "Failed to start CPG timer!");
        return;
    }
}

void CPG_app_main(void) {

    ESP_LOGI(TAG, "settingup the motor comnads");

    cpg_params_mutex = xSemaphoreCreateMutex(); 
    if (cpg_params_mutex == NULL) {
        ESP_LOGE(TAG, "Failed to create CPG mutex!");
    }

    
    // One-time phase initialization 
    for (int i = 0; i < NUM_OSCILLATORS; i++) {
       cpg_network[i].phase = 0.0f;
    }
    vTaskDelay(pdMS_TO_TICKS(100));

    // --- NEW CPG Setup ---
    ESP_LOGI(TAG, "Initializing CPG network...");
    // Initialize to a safe state
    set_gait_idle(); 
    // ---

    static TaskHandle_t seq_runner_handle = NULL;

   xTaskCreatePinnedToCore(sequence_runner_task, 
                            "seq_runner",
                             4096, 
                             NULL, 
                             9, 
                             &seq_runner_handle, 
                             1);

    vTaskDelay(pdMS_TO_TICKS(100));

    // --- CPG Task ---
    xTaskCreatePinnedToCore(cpg_update_task, 
                            "cpg_updater", 
                            4096, // CPG task might need stack for float math
                            NULL, 
                            20, // Higher priority than sequence runner
                            &cpg_task_handle, 
                            1); // Pin to core 1
    // ---
    vTaskDelay(pdMS_TO_TICKS(100));

    hardware_Timer_setup();
    vTaskDelay(pdMS_TO_TICKS(100));

    ESP_LOGI(TAG, "settingup the motor comnads complete");
}

////////////////////////////////header///////////////////////////////////////////////////////////////////

#pragma once

#include "control_1.7.h" 

// CPG update loop timing
#define CPG_UPDATE_RATE_HZ 2500 //HZ
#define CPG_DT (1.0f / CPG_UPDATE_RATE_HZ)  //seconds
#define CPG_UPDATE_RATE_US CPG_DT*1000000.0f // microseconds
#define PID_DT CPG_DT //seconds
//=============================================================PID==================================================

// ====================== PID Structure ======================
typedef struct {
    float Kp, Ki, Kd;
    float T;                                
    float limMin, limMax;     
    float limMinInt, limMaxInt; 

    float proportional,differentiator,integrator;
    float error,prevError;
    float prevMeasurement;
    float output,lastOutput;

} PIDController;

// ====================== Motor Structure ======================
typedef struct {
    uint8_t m_num;
    float target_position,prev_target;
    int current_position;   
    int last_enc_val;
    bool active;
 
    PIDController pos_pid;    
} Motor;

typedef struct {
    float motor_target;  // Array to hold the target positions for all motors
    bool activate;
} motor_Command_t;

typedef struct {
    float error;
    float proportional;
    float derivative;
    float integrator;
    int32_t encorder_val;
} PID_debugger_log;

extern Motor motor_log[NUM_MOTORS];
extern QueueHandle_t motor_command_queue;

#define PWM_MAX         1023.0f    // full-scale PWM
#define PWM_MIN         400.0f//1010  // minimum duty to move motor
#define PWM_STOP        0       // below this -> fully stop (coast)
#define TOL             1000    // position tolerance (encoder ticks)
#define COUNTS_PER_REV  28      // adjust for your encoder
#define MIN_DUTY        (PWM_MIN * 0.6f)  // 60% of minimum motion duty
#define STOP_THRESHOLD   30 

// ====================== SAFE DOUBLE BUFFER ======================
extern volatile float motor_cmd_buffer[2][NUM_MOTORS];
extern volatile uint8_t current_write_index;  // PID reads from this
extern portMUX_TYPE pid_buffer_swap_mux;

void pid_app_main(void);


//==========================================CPG=====================================================================

#define NUM_OSCILLATORS NUM_MOTORS // 8 oscillators for 8 motors
#define CMD_BUFFER_SIZE 2 

// Define motor indices to make life easier
// Assuming 2 motors/leg: Hip (forward/back) and Knee (up/down)
#define FLH 0 // Front-Left Hip
#define FLK 1 // Front-Left Knee
#define FRH 2 // Front-Right Hip
#define FRK 3 // Front-Right Knee
#define BLH 4 // Back-Left Hip
#define BLK 5 // Back-Left Knee
#define BRH 6 // Back-Right Hip
#define BRK 7 // Back-Right knee_amp                                

typedef struct {
    float phase;        // Current phase (0 to 2*PI)
    float omega;        // Natural angular frequency (2*PI*f)
    float amplitude;    // Output amplitude (e.g., 1000 encoder counts)
    float offset;       // Output offset (center position)
    float output;       // The final calculated setpoint
} Oscillator;

typedef struct{
 float base_freq;
 float hip_amp ;
 float knee_amp;
 float hip_offset; 
 float knee_offset;
 float KH_offset;
 float max_amp;
 float knee_omega_mult;  // Default 2.0 (knees 2x hips)
 float hip_omega_mult;   // Default 1.0 (base)
}osc_pram;

typedef enum {
    MODE_IDLE = 0,
    MODE_CRAWL,
    MODE_STANDBY,
    MODE_TURTLE
} SequenceMode;

// The global CPG network
extern Oscillator cpg_network[NUM_OSCILLATORS];
// Global gait parameter matrices
// These define the "brain" of the gait
extern float coupling_weights[NUM_OSCILLATORS][NUM_OSCILLATORS];
extern float phase_offsets[NUM_OSCILLATORS][NUM_OSCILLATORS];
void CPG_app_main(void);
void Update_Oscillator_base_parameters(void);